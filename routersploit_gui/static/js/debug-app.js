// RouterSploit GUI - Debug Version
// This simplified version focuses on core functionality

console.log('üîß Debug App Loading...');

class DebugRouterSploitGUI {
    constructor() {
        console.log('üöÄ Debug RouterSploit GUI starting...');
        this.modules = {};
        this.moduleTree = {};
        this.socket = null;
        this.init();
    }
    
    init() {
        console.log('üîß Initializing debug app...');
        
        // Wait for DOM
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.setup());
        } else {
            this.setup();
        }
    }
    
    setup() {
        console.log('üîß Setting up debug app...');
        
        try {
            // Test basic DOM access
            this.testDOMAccess();
            
            // Test server connectivity
            this.testServerConnectivity();
            
            // Initialize Socket.IO
            this.initSocket();
            
            // Setup button handlers
            this.setupButtons();
            
            // Load modules
            this.loadModules();
            
            console.log('‚úÖ Debug app setup complete');
            
        } catch (error) {
            console.error('‚ùå Debug app setup failed:', error);
            this.showError('App initialization failed: ' + error.message);
        }
    }
    
    testDOMAccess() {
        console.log('üß™ Testing DOM access...');
        
        const elements = {
            'startAutoOwnBtn': document.getElementById('startAutoOwnBtn'),
            'autoOwnTarget': document.getElementById('autoOwnTarget'),
            'openaiApiKey': document.getElementById('openaiApiKey'),
            'saveApiKeyBtn': document.getElementById('saveApiKeyBtn'),
            'moduleTree': document.getElementById('moduleTree'),
            'runBtn': document.getElementById('runBtn'),
            'statusBadge': document.getElementById('statusBadge')
        };
        
        console.log('üîç Element availability:', elements);
        
        let missing = [];
        for (const [name, element] of Object.entries(elements)) {
            if (!element) {
                missing.push(name);
            }
        }
        
        if (missing.length > 0) {
            console.warn('‚ö†Ô∏è Missing elements:', missing);
        } else {
            console.log('‚úÖ All required elements found');
        }
    }
    
    async testServerConnectivity() {
        console.log('üåê Testing server connectivity...');
        
        try {
            const response = await fetch('/api/auto-own/check-api-key', {
                method: 'GET',
                headers: { 'Accept': 'application/json' }
            });
            
            console.log('üåê Server connectivity test response:', response.status);
            
            if (response.ok) {
                const data = await response.json();
                console.log('‚úÖ Server is reachable, API key status:', data);
            } else {
                console.warn('‚ö†Ô∏è Server responded but with error:', response.status);
            }
        } catch (error) {
            console.error('‚ùå Server connectivity test failed:', error);
            console.error('üö® WARNING: Cannot reach server! Button clicks may not work.');
        }
    }
    
    initSocket() {
        try {
            console.log('üîå Initializing Socket.IO...');
            if (typeof io === 'undefined') {
                console.warn('‚ö†Ô∏è Socket.IO not available');
                return;
            }
            
            this.socket = io();
            
            this.socket.on('connect', () => {
                console.log('üîå Socket connected');
                this.updateStatus('Connected', 'success');
            });
            
            this.socket.on('disconnect', () => {
                console.log('üîå Socket disconnected');
                this.updateStatus('Disconnected', 'danger');
            });
            
            // Auto-Own event handlers
            this.socket.on('auto_own_output', (data) => {
                console.log('ü§ñ Auto-Own output received:', data);
                this.addAutoOwnOutput(data.line, data.level);
            });
            
            this.socket.on('auto_own_complete', (data) => {
                console.log('ü§ñ Auto-Own completed:', data);
                this.onAutoOwnComplete(data.success, data.error);
            });
            
            this.socket.on('auto_own_progress', (data) => {
                console.log('ü§ñ Auto-Own progress:', data);
                this.updateAutoOwnProgress(data.status, data.percentage);
            });
            
            console.log('‚úÖ Socket.IO initialized');
            
        } catch (error) {
            console.error('‚ùå Socket.IO initialization failed:', error);
        }
    }
    
    setupButtons() {
        console.log('üîß Setting up button handlers...');
        
        // Auto-Own Start Button
        const startBtn = document.getElementById('startAutoOwnBtn');
        if (startBtn) {
            startBtn.addEventListener('click', (e) => {
                console.log('üéØ Auto-Own start button clicked!');
                e.preventDefault();
                this.startAutoOwn();
            });
            console.log('‚úÖ Auto-Own start button handler added');
        } else {
            console.error('‚ùå startAutoOwnBtn not found');
        }
        
        // Auto-Own Target Input (Enter key)
        const targetInput = document.getElementById('autoOwnTarget');
        if (targetInput) {
            targetInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    console.log('‚ö° Auto-Own target Enter pressed!');
                    e.preventDefault();
                    this.startAutoOwn();
                }
            });
            
            // Test typing
            targetInput.addEventListener('input', (e) => {
                console.log('üìù Target input changed:', e.target.value);
            });
            
            console.log('‚úÖ Auto-Own target input handlers added');
        } else {
            console.error('‚ùå autoOwnTarget not found');
        }
        
        // API Key Save Button
        const saveApiBtn = document.getElementById('saveApiKeyBtn');
        if (saveApiBtn) {
            console.log('‚úÖ Found saveApiKeyBtn. Adding listener...');
            saveApiBtn.addEventListener('click', (e) => {
                console.log('--- SAVE API KEY BUTTON CLICK DETECTED ---');
                e.preventDefault();
                this.saveApiKey();
            });
            console.log('‚úÖ API key save button handler added');
        } else {
            console.error('‚ùå saveApiKeyBtn not found');
        }
        
        // Run Button
        const runBtn = document.getElementById('runBtn');
        if (runBtn) {
            runBtn.addEventListener('click', (e) => {
                console.log('‚ñ∂Ô∏è Run button clicked!');
                e.preventDefault();
                alert('Run button works! Module execution would happen here.');
            });
            console.log('‚úÖ Run button handler added');
        } else {
            console.error('‚ùå runBtn not found');
        }
    }
    
    async loadModules() {
        console.log('üìö Loading modules...');
        
        const moduleTree = document.getElementById('moduleTree');
        if (!moduleTree) {
            console.error('‚ùå moduleTree container not found');
            return;
        }
        
        // Show loading
        moduleTree.innerHTML = `
            <div class="text-center p-3">
                <div class="spinner-border text-primary" role="status"></div>
                <p class="mt-2">Loading modules...</p>
            </div>
        `;
        
        try {
            console.log('üì° Fetching modules from API...');
            const response = await fetch('/api/modules');
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            console.log('üìä Modules loaded:', {
                count: data.count,
                treeKeys: Object.keys(data.tree || {})
            });
            
            this.modules = data.modules || {};
            this.moduleTree = data.tree || {};
            
            this.renderModuleTree();
            
            console.log('‚úÖ Modules loaded successfully');
            
        } catch (error) {
            console.error('‚ùå Failed to load modules:', error);
            moduleTree.innerHTML = `
                <div class="text-center p-3 text-danger">
                    <i class="fas fa-exclamation-triangle"></i>
                    <p>Failed to load modules</p>
                    <small>${error.message}</small>
                    <button class="btn btn-warning btn-sm mt-2" onclick="window.debugApp.loadModules()">
                        Retry
                    </button>
                </div>
            `;
        }
    }
    
    renderModuleTree() {
        console.log('üå≥ Rendering module tree...');
        
        const moduleTree = document.getElementById('moduleTree');
        if (!moduleTree) {
            console.error('‚ùå moduleTree container not found');
            return;
        }
        
        if (!this.moduleTree || Object.keys(this.moduleTree).length === 0) {
            moduleTree.innerHTML = `
                <div class="text-center p-3 text-warning">
                    <i class="fas fa-info-circle"></i>
                    <p>No modules found</p>
                </div>
            `;
            return;
        }
        
        try {
            moduleTree.innerHTML = '';
            
            // Create simplified tree structure
            for (const [categoryName, categoryData] of Object.entries(this.moduleTree)) {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'tree-category p-2 border-bottom';
                categoryDiv.innerHTML = `
                    <div class="fw-bold text-primary">
                        <i class="fas fa-folder"></i> ${categoryName.toUpperCase()}
                        <span class="badge bg-secondary ms-2">${this.getModuleCount(categoryData)}</span>
                    </div>
                `;
                
                categoryDiv.addEventListener('click', () => {
                    console.log(`üìÅ Category clicked: ${categoryName}`);
                    this.toggleCategory(categoryName);
                });
                
                moduleTree.appendChild(categoryDiv);
            }
            
            console.log('‚úÖ Module tree rendered');
            
        } catch (error) {
            console.error('‚ùå Failed to render module tree:', error);
            moduleTree.innerHTML = `
                <div class="text-center p-3 text-danger">
                    <p>Error rendering modules</p>
                    <small>${error.message}</small>
                </div>
            `;
        }
    }
    
    getModuleCount(categoryData) {
        if (!categoryData || typeof categoryData !== 'object') return 0;
        
        let count = 0;
        
        // Count direct modules
        if (categoryData.modules && Array.isArray(categoryData.modules)) {
            count += categoryData.modules.length;
        }
        
        // Count modules in subcategories
        if (categoryData.categories) {
            for (const subCategory of Object.values(categoryData.categories)) {
                count += this.getModuleCount(subCategory);
            }
        }
        
        // Count other objects that might be modules
        for (const [key, value] of Object.entries(categoryData)) {
            if (key !== 'modules' && key !== 'categories' && value && typeof value === 'object') {
                if (value.dotted_path) {
                    count += 1; // This is a module
                } else {
                    count += this.getModuleCount(value); // This is a nested category
                }
            }
        }
        
        return count;
    }
    
    toggleCategory(categoryName) {
        console.log(`üîÑ Toggle category: ${categoryName}`);
        alert(`Category "${categoryName}" clicked! Module selection would be implemented here.`);
    }
    
    async startAutoOwn() {
        console.log('ü§ñ Starting Auto-Own...');
        
        const targetInput = document.getElementById('autoOwnTarget');
        const verboseCheckbox = document.getElementById('autoOwnVerbose');
        const debugCheckbox = document.getElementById('autoOwnDebug');
        
        if (!targetInput) {
            console.error('‚ùå Target input not found');
            alert('Target input not found!');
            return;
        }
        
        const target = targetInput.value.trim();
        if (!target) {
            console.warn('‚ö†Ô∏è No target specified');
            this.addAutoOwnOutput('‚ö†Ô∏è Please enter a target IP address', 'warning');
            return;
        }
        
        const isVerbose = verboseCheckbox ? verboseCheckbox.checked : false;
        const isDebug = debugCheckbox ? debugCheckbox.checked : false;
        
        console.log(`üéØ Auto-Own parameters: target="${target}", verbose=${isVerbose}, debug=${isDebug}`);
        
        try {
            this.updateStatus('Starting Auto-Own...', 'warning');
            
            console.log('üì° Sending Auto-Own request...');
            const response = await fetch('/api/auto-own/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ target, verbose: isVerbose, debug: isDebug })
            });
            
            console.log('üì° Response status:', response.status);
            const result = await response.json();
            console.log('üì° Response data:', result);
            
            if (response.ok && result.status === 'started') {
                console.log('‚úÖ Auto-Own started successfully');
                this.addAutoOwnOutput(`üöÄ Auto-Own started for target: ${target}`, 'success');
                this.addAutoOwnOutput(`üîç Initializing AI agent and scanning target...`, 'info');
                this.updateStatus('Auto-Own Running', 'success');
            } else {
                throw new Error(result.error || 'Unknown error');
            }
            
        } catch (error) {
            console.error('‚ùå Auto-Own failed:', error);
            this.addAutoOwnOutput(`‚ùå Failed to start Auto-Own: ${error.message}`, 'error');
            this.updateStatus('Auto-Own Failed', 'danger');
        }
    }
    
    async saveApiKey() {
        alert("--- DEBUG: saveApiKey function has been called! ---");
        console.log('--- saveApiKey function started! ---');
        console.log('üîë Saving API key...');
        console.log('üîë Function called at:', new Date().toISOString());
        
        const apiKeyInput = document.getElementById('openaiApiKey');
        if (!apiKeyInput) {
            console.error('‚ùå API key input not found');
            this.showError('API key input not found!');
            return;
        }
        
        const apiKey = apiKeyInput.value.trim();
        console.log('üîë API key length:', apiKey.length);
        console.log('üîë API key starts with:', apiKey.substring(0, 8));
        
        if (!apiKey) {
            console.warn('‚ö†Ô∏è No API key specified');
            this.showError('Please enter an API key');
            return;
        }
        
        const saveBtn = document.getElementById('saveApiKeyBtn');
        
        try {
            // Show saving state
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
                console.log('üîë Button state updated to saving...');
            }
            
            console.log('üîë About to make fetch call...');
            console.log('üîë Fetch URL: /api/auto-own/set-api-key');
            console.log('üîë Fetch method: POST');
            console.log('üîë Content-Type: application/json');
            
            const requestBody = JSON.stringify({ api_key: apiKey });
            console.log('üîë Request body length:', requestBody.length);
            console.log('üîë Request body preview:', requestBody.substring(0, 50) + '...');
            
            // Add a unique timestamp to prevent caching
            const timestamp = Date.now();
            const url = `/api/auto-own/set-api-key?t=${timestamp}`;
            console.log('üîë Final URL with timestamp:', url);
            
            console.log('üîë Starting fetch request...');
            
            // Send to backend to save in file (where Python reads from)
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'Cache-Control': 'no-cache'
                },
                body: requestBody
            });
            
            console.log('üîë Fetch completed!');
            console.log('üîë Response status:', response.status);
            console.log('üîë Response statusText:', response.statusText);
            console.log('üîë Response headers:', Object.fromEntries(response.headers.entries()));
            
            if (!response.ok) {
                console.error('üîë Response not OK, getting error text...');
                const errorText = await response.text();
                console.error('üîë Backend HTTP error:', response.status, errorText);
                throw new Error(`HTTP ${response.status}: ${errorText}`);
            }
            
            console.log('üîë Response OK, parsing JSON...');
            const result = await response.json();
            console.log('üîë Backend JSON result:', result);
            
            if (result.status === 'success') {
                console.log('üîë Backend save successful!');
                
                // Also save to localStorage as backup
                localStorage.setItem('openai_api_key', apiKey);
                console.log('üîë Also saved to localStorage');
                
                console.log('‚úÖ API key saved to backend file and localStorage');
                this.updateStatus('API Key Saved to Backend', 'success');
                
                // Clear input for security
                apiKeyInput.value = '';
                console.log('üîë Input field cleared');
                
                // Show success message
                this.showSuccess('API key saved successfully to backend file!');
                
            } else {
                console.error('‚ùå Backend save failed with result:', result);
                throw new Error(result.error || 'Failed to save API key to backend');
            }
            
        } catch (error) {
            console.error('‚ùå Exception in saveApiKey:', error);
            console.error('‚ùå Error name:', error.name);
            console.error('‚ùå Error message:', error.message);
            console.error('‚ùå Error stack:', error.stack);
            
            // Check if it's a network error
            if (error instanceof TypeError && error.message.includes('fetch')) {
                console.error('üåê Network error detected - server might be down');
                this.showError('Network error: Cannot connect to server. Is the server running?');
            } else {
                console.log('‚ö†Ô∏è Falling back to localStorage only due to error:', error.message);
                
                // Fallback: save to localStorage only
                try {
                    localStorage.setItem('openai_api_key', apiKey);
                    console.log('‚ö†Ô∏è API key saved to localStorage as fallback');
                    this.updateStatus('API Key Saved (localStorage only)', 'warning');
                    this.showError('Failed to save to backend, saved locally only: ' + error.message);
                } catch (storageError) {
                    console.error('‚ùå Even localStorage save failed:', storageError);
                    this.showError('Failed to save API key: ' + error.message);
                }
            }
        } finally {
            // Restore button state
            if (saveBtn) {
                saveBtn.disabled = false;
                saveBtn.innerHTML = '<i class="fas fa-save"></i> Save';
                console.log('üîë Button state restored');
            }
            console.log('üîë saveApiKey function completed at:', new Date().toISOString());
        }
    }
    
    updateStatus(text, type) {
        const statusBadge = document.getElementById('statusBadge');
        if (statusBadge) {
            statusBadge.innerHTML = `<i class="fas fa-circle"></i> <span>${text}</span>`;
            statusBadge.className = `badge bg-${type} holographic`;
            console.log(`üîÑ Status updated: ${text} (${type})`);
        }
    }
    
    showSuccess(message) {
        console.log('‚úÖ Success:', message);
        this.addAutoOwnOutput(`‚úÖ Success: ${message}`, 'success');
        this.updateStatus('Success', 'success');
    }
    
    showError(message) {
        console.error('‚ùå Error:', message);
        this.addAutoOwnOutput(`‚ùå Error: ${message}`, 'error');
        this.updateStatus('Error', 'danger');
    }
    
    // Auto-Own output methods
    addAutoOwnOutput(line, level) {
        console.log(`üìù Adding Auto-Own output: [${level}] ${line}`);
        
        const outputContainer = document.getElementById('autoOwnOutput');
        if (!outputContainer) {
            console.error('‚ùå autoOwnOutput container not found');
            return;
        }
        
        const outputLine = document.createElement('div');
        outputLine.className = `auto-own-line mb-1`;
        
        // Add timestamp
        const timestamp = new Date().toLocaleTimeString();
        const timestampSpan = document.createElement('span');
        timestampSpan.className = 'text-muted me-2';
        timestampSpan.textContent = `[${timestamp}]`;
        outputLine.appendChild(timestampSpan);
        
        // Add content with appropriate styling
        const contentSpan = document.createElement('span');
        contentSpan.textContent = line;
        
        switch (level) {
            case 'success':
                contentSpan.className = 'text-success';
                break;
            case 'error':
                contentSpan.className = 'text-danger';
                break;
            case 'warning':
                contentSpan.className = 'text-warning';
                break;
            case 'info':
                contentSpan.className = 'text-info';
                break;
            default:
                contentSpan.className = 'text-light';
        }
        
        outputLine.appendChild(contentSpan);
        outputContainer.appendChild(outputLine);
        
        // Auto-scroll to bottom
        outputContainer.scrollTop = outputContainer.scrollHeight;
    }
    
    onAutoOwnComplete(success, error) {
        console.log(`üèÅ Auto-Own completed: success=${success}, error=${error}`);
        
        if (success) {
            this.addAutoOwnOutput('üéâ Auto-Own process completed successfully!', 'success');
            this.updateStatus('Auto-Own Complete', 'success');
        } else {
            this.addAutoOwnOutput(`‚ùå Auto-Own process failed: ${error}`, 'error');
            this.updateStatus('Auto-Own Failed', 'danger');
        }
    }
    
    updateAutoOwnProgress(status, percentage) {
        console.log(`üìä Auto-Own progress: ${status} (${percentage}%)`);
        
        // Update progress in output
        this.addAutoOwnOutput(`üìä Progress: ${status} (${Math.round(percentage)}%)`, 'info');
    }
}

// Initialize when DOM is ready
console.log('üîß Debug app script loaded, waiting for DOM...');

document.addEventListener('DOMContentLoaded', () => {
    console.log('üîß DOM ready, initializing debug app...');
    window.debugApp = new DebugRouterSploitGUI();
});

// Fallback for already loaded DOM
if (document.readyState !== 'loading') {
    console.log('üîß DOM already loaded, initializing debug app immediately...');
    window.debugApp = new DebugRouterSploitGUI();
}

console.log('‚úÖ Debug app script fully loaded'); 